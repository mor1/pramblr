#!/usr/bin/env -S uv run --env-file /home/mort/.local/bin/.env-pramblr --script
# /// script
# requires-python = ">=3.12"
# dependencies = [
#   "beautifulsoup4>=4.14.3",
#   "gpxplotter>=0.2.12",
#   "rich>=13.7.1",
#   "click>=8.1.8",
#   "yaml-rs>=0.0.10",
# ]
# ///

# SPDX-FileCopyrightText: (C) Richard Mortier <mort@cantab.net>
#
# SPDX-License-Identifier: BSD-3-Clause

"""Produce Ramblr-like pages from GPX files and photos."""

# pyright: reportAny=false
# pyright: reportAttributeAccessIssue=false
# pyright: reportMissingParameterType=false
# pyright: reportPrivateLocalImportUsage=false
# pyright: reportUnknownArgumentType=false
# pyright: reportUnknownMemberType=false
# pyright: reportUnknownParameterType=false
# pyright: reportUnknownVariableType=false
# pyright: reportUntypedFunctionDecorator=false
# pyright: reportOptionalMemberAccess

import io
import logging
import pathlib
import warnings
from typing import override

import bs4
import click
import folium
import gpxplotter as gx
import numpy as np
import yaml_rs as yaml
from rich.console import Console
from rich.logging import RichHandler
from sklearn.cluster import KMeans

errcon = Console(stderr=True)
logging.basicConfig(
    level="INFO",
    format="%(message)s",
    datefmt="[%X]",
    handlers=[RichHandler(console=errcon, rich_tracebacks=True)],
)
log = logging.getLogger(__name__)


class BytesIONoClose(io.BytesIO):
    """In-memory BytesIO file-like object, that doesn't close on save()."""

    @override
    def close(self):
        pass


# cluster_velocities() throws an error if you pass in a segment with fewer than
# `n_clusters`(default: 5) waypoints. One of my tracks has a segment with only
# four it turns out. So, monkey patch the funciton to clip `n_clusters` to the
# minimum of 5 and the number of waypoints provided.
def monkey_patch_cluster_velocities(velocities, n_clusters=5):
    """Group the velocities into a predefined set of clusters.

    This is used to label velocities as `faster`, `slower`, etc.

    Parameters
    ----------
    velocities : array_like
        The velocities to cluster.
    n_clusters : int, optional
        The number of clusters to look for.

    Returns
    -------
    levels : array_like
        The velocity level (cluster) each velocity is assigned to.

    """

    if np.isnan(velocities).any():
        warnings.warn("Some velocities are NaN, skipping clustering")
        return None
    vel = np.array(velocities).reshape(-1, 1)
    n_clusters = min(n_clusters, velocities.shape[0])
    clu = KMeans(n_clusters=n_clusters, init="k-means++", n_init=10)
    labels = clu.fit_predict(vel)
    # Sort labels according to cluster centers so that a lower label
    # is a lower velocity:
    centers = clu.cluster_centers_.flatten()
    idx = list(np.argsort(centers))
    levels = np.array([idx.index(i) for i in labels], dtype=np.int_)
    return levels


gx.gpxread.cluster_velocities = monkey_patch_cluster_velocities


def build_map(gpxs) -> bytes:
    """Build a map with the tracks overlaid."""
    map = gx.create_folium_map()
    for gpx in gpxs:
        with open(gpx, "r") as fp:
            for track in gx.read_gpx_file(fp):
                for segment in track["segments"]:
                    gx.add_segment_to_map(map, segment)

    folium.LayerControl(sortLayers=True).add_to(map)
    html = BytesIONoClose()
    map.save(html)
    return html.getvalue()


@click.command(context_settings={"show_default": True, "ignore_unknown_options": True})
@click.argument("configf", required=False, type=click.File("r"))
@click.option("--debug", default=False, is_flag=True, help="Turn on verbose logging.")
@click.option(
    "--outf",
    required=False,
    type=click.Path(dir_okay=False, writable=True, allow_dash=True, path_type=None),
)
@click.option(
    "--title", type=str, default="Untitled map", help="Title of the generated map."
)
@click.option(
    "--gpxs",
    type=click.Path(exists=True, dir_okay=True, path_type=pathlib.Path),
    multiple=True,
    help="GPX files of the track.",
)
@click.option(
    "--photos",
    type=click.Path(exists=True, dir_okay=True, path_type=pathlib.Path),
    multiple=True,
    help="Photos from the track.",
)
def pramblr(
    configf: click.File,
    debug: bool,
    outf: str,
    title: str,
    gpxs: tuple[pathlib.Path, ...],
    photos: tuple[pathlib.Path, ...],
) -> None:
    """."""

    # verbose logging
    if debug:
        log.setLevel(logging.DEBUG)

    # parse configuration if provided
    config = yaml.loads(configf.read()) if configf else None
    log.debug(config)

    # output filename
    outf: str = config.get("outf", outf) if config else ("-" if not outf else outf)
    log.debug(f"{outf=}")

    # title
    title: str = config.get("title", outf) if config else title
    log.debug(f"{title=}")

    # build list of GPX tracks
    gpxs = (
        tuple(pathlib.Path(p).expanduser() for p in config.get("gpxs", gpxs))
        if config
        else gpxs
    )
    log.debug(f"{gpxs=}")

    # build list of photos
    photos = (
        tuple(pathlib.Path(p).expanduser() for p in config.get("photos", photos))
        if config
        else photos
    )
    log.debug(f"{photos=}")

    # make map and munge its HTML
    html = build_map(gpxs)
    soup = bs4.BeautifulSoup(html, "html.parser")
    soup.title = soup.new_tag("title")
    soup.title.string = title
    scripts = soup.find_all("script")

    # grab HTML of the map
    with click.open_file(outf, "w") as fp:
        _ = fp.write(soup.prettify())


if __name__ == "__main__":
    pramblr()
