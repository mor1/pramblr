#!/usr/bin/env -S uv run --env-file /home/mort/.local/bin/.env-pramblr --script
# /// script
# requires-python = ">=3.12"
# dependencies = [
#   "beautifulsoup4>=4.14.3",
#   "click>=8.1.8",
#   "gpxplotter>=0.2.12",
#   "pillow-heif>=1.1.1",
#   "pillow>=12.1.0",
#   "rich>=13.7.1",
#   "timezonefinder>=8.2.1",
#   "yaml-rs>=0.0.10",
#   "yattag>=1.16.1",
# ]
# ///

# SPDX-FileCopyrightText: (C) Richard Mortier <mort@cantab.net>
#
# SPDX-License-Identifier: BSD-3-Clause

"""Produce Ramblr-like pages from GPX files and photos."""

# pyright: reportAny=false
# pyright: reportAttributeAccessIssue=false
# pyright: reportMissingParameterType=false
# pyright: reportOptionalMemberAccess=false
# pyright: reportPrivateLocalImportUsage=false
# pyright: reportUnknownArgumentType=false
# pyright: reportUnknownMemberType=false
# pyright: reportUnknownParameterType=false
# pyright: reportUnknownVariableType=false
# pyright: reportUntypedFunctionDecorator=false

import logging

from rich.console import Console
from rich.logging import RichHandler

errcon = Console(stderr=True)
logging.basicConfig(
    level="INFO",
    format="%(funcName)s:%(lineno)d %(message)s",
    datefmt="[%X]",
    handlers=[RichHandler(console=errcon, rich_tracebacks=True)],
)
log = logging.getLogger(__name__)

import os  # noqa:E402
import sys  # noqa:E402

if os.path.isfile("/etc/NIXOS") and (
    "-gcc-" not in os.environ.get("LD_LIBRARY_PATH", "")
):
    log.fatal("You must `unset LD_LIBRARY_PATH` when running NixOS")
    sys.exit(1)

import datetime as dt  # noqa: E402
import glob  # noqa: E402
import io  # noqa:E402
import warnings  # noqa:E402
from pathlib import Path  # noqa:E402
from typing import override  # noqa:E402
from zoneinfo import ZoneInfo  # noqa:E402

import bs4  # noqa:E402
import click  # noqa:E402
import folium  # noqa:E402
import folium.plugins  # noqa:E402
import gpxplotter as gx  # noqa:E402
import numpy as np  # noqa:E402
import PIL  # noqa: E402
import PIL.ExifTags as exiftags  # noqa: E402
import pillow_heif  # noqa: E402
import yaml_rs as yaml  # noqa:E402
from sklearn.cluster import KMeans  # noqa:E402
from timezonefinder import timezone_at  # noqa:E402
from yattag import Doc  # noqa:E402

SUPPORTED_IMAGE_FORMATS = (".jpg", ".jpeg", ".heic")


class BytesIONoClose(io.BytesIO):
    """In-memory BytesIO file-like object, that doesn't close on save()."""

    @override
    def close(self):
        pass


# cluster_velocities() throws an error if you pass in a segment with fewer than
# `n_clusters`(default: 5) waypoints. One of my tracks has a segment with only
# four it turns out. So, monkey patch the funciton to clip `n_clusters` to the
# minimum of 5 and the number of waypoints provided.
def monkey_patch_cluster_velocities(velocities, n_clusters=5):
    """Group the velocities into a predefined set of clusters.

    This is used to label velocities as `faster`, `slower`, etc.

    Parameters
    ----------
    velocities : array_like
        The velocities to cluster.
    n_clusters : int, optional
        The number of clusters to look for.

    Returns
    -------
    levels : array_like
        The velocity level (cluster) each velocity is assigned to.

    """

    if np.isnan(velocities).any():
        warnings.warn("Some velocities are NaN, skipping clustering")
        return None
    vel = np.array(velocities).reshape(-1, 1)
    n_clusters = min(n_clusters, velocities.shape[0])
    clu = KMeans(n_clusters=n_clusters, init="k-means++", n_init=10)
    labels = clu.fit_predict(vel)
    # Sort labels according to cluster centers so that a lower label
    # is a lower velocity:
    centers = clu.cluster_centers_.flatten()
    idx = list(np.argsort(centers))
    levels = np.array([idx.index(i) for i in labels], dtype=np.int_)
    return levels


gx.gpxread.cluster_velocities = monkey_patch_cluster_velocities


def convert_photos(outf: str, photos: tuple[Path], overwrite: bool) -> list[Path]:
    webps: list[Path] = []
    prefix: Path = Path(outf).parent.expanduser()

    prefix.mkdir(exist_ok=True, parents=True)
    webps_to_delete = [Path(p) for p in glob.glob(str(prefix / "*.webp"))]
    log.debug(f"{webps_to_delete=}")

    for photo in [
        p for p in photos if Path(p).suffix.lower() in SUPPORTED_IMAGE_FORMATS
    ]:
        output = prefix / Path(photo).with_suffix(".webp").name

        if output in webps:
            log.warning(f"{photo=} would overwrite existing {output=}; skipping")
            continue

        if output in webps_to_delete:
            webps_to_delete.remove(output)

        webps.append(output)

        if not overwrite and output.is_file() and os.access(output, os.R_OK):
            log.info(f"skipping file {output}")
            continue

        with PIL.Image.open(photo).convert("RGB") as image:
            log.info(f"converting {photo=} to {output=}")
            image.thumbnail((640, 480))
            PIL.ImageOps.exif_transpose(image, in_place=True)
            image.save(output, "WEBP", quality=85, exif=image.getexif(), optimize=True)

    for f in webps_to_delete:
        log.info(f"removing {f=} as no longer referenced in configuration")
        f.unlink()

    return webps


def timestamp_of(image) -> dt.datetime:
    exif = image.getexif()
    exifinfo = {exiftags.TAGS.get(k, k): v for k, v in exif.items()}
    timestamp = dt.datetime.strptime(exifinfo["DateTime"], "%Y:%m:%d %H:%M:%S")
    log.debug(f"{timestamp=}")
    return timestamp


def location_of(image, debug=False) -> tuple[float, float] | None:
    exif = image.getexif()
    exifinfo = {exiftags.TAGS.get(k, k): v for k, v in exif.items()}

    ifdkey = [k for k, v in exiftags.TAGS.items() if v == "GPSInfo"][0]
    ifd = exif.get_ifd(ifdkey)

    gpsinfo = {exiftags.GPSTAGS.get(k, k): v for k, v in ifd.items()}
    if "GPSLatitude" not in gpsinfo:
        return None

    latitude = longitude = 0.0
    try:
        degrees, minutes, seconds = gpsinfo["GPSLatitude"]
        latitude = degrees + (minutes / 60.0) + (seconds / 3600.0)
        if gpsinfo["GPSLatitudeRef"] == "S":
            latitude *= -1

        degrees, minutes, seconds = gpsinfo["GPSLongitude"]
        longitude = degrees + (minutes / 60.0) + (seconds / 3600.0)
        if gpsinfo["GPSLongitudeRef"] == "W":
            longitude *= -1

    except KeyError as ke:
        if debug:
            log.exception(f"{ke=}")
        return None

    log.debug(f"{latitude=} {longitude=}")
    return latitude, longitude


def interpolate_location(timestamp, segment) -> tuple[float, float] | None:
    # get the timezone for the track(s)
    lat, lng = segment["latlon"][0]
    tz = ZoneInfo(timezone_at(lat=lat, lng=lng))
    log.debug(f"{lat=} {lng=} {tz=} {segment['latlon'][:5]=}")

    timestamp = timestamp.replace(tzinfo=tz)
    times = [t.astimezone(tz) for t in segment["time"]]
    diff = []
    for i, t in enumerate(times):
        d = abs((timestamp - t).total_seconds())
        diff.append(d)

    bestidx = diff.index(min(diff))
    (latitude, longitude) = segment["latlon"][bestidx]
    log.debug(f"{timestamp=} {bestidx=} {diff[bestidx]=} {latitude=} {longitude=}")
    return latitude, longitude


def extend(
    lsegment: dict[str, np.ndarray | np.float64 | list],
    rsegment: dict[str, np.ndarray | np.float64 | list],
) -> dict[str, np.ndarray | np.float64 | list]:
    for k, v in rsegment.items():
        match v:
            case list():
                if k not in lsegment:
                    lsegment[k] = []
                lsegment[k].extend(v)
            case np.ndarray():
                if k not in lsegment:
                    lsegment[k] = np.empty_like(rsegment[k])
                lsegment[k] = np.concatenate([lsegment[k], v])
            case np.float64():  # noqa: reportUnnecessaryComparison
                if k not in lsegment:
                    lsegment[k] = np.float64(0)
                lsegment[k] += rsegment[k]
            case int():
                pass

    return lsegment


def build_map(gpxs, webps) -> bytes:
    """Build a map with the tracks overlaid."""

    # Create the map object
    map = gx.create_folium_map(control_scale=True)

    # Accumulate track segments from each file into a `trackseg` so we can add
    # start/end markers corresponding to each file (~day) and into `segment` so
    # we get a single colormap legend.
    segment: dict[str, np.ndarry | list] = {}
    for gpxfile in gpxs:
        log.info(f"Processing GPX track {gpxfile=}")
        with open(gpxfile, "r") as fp:
            for track in gx.read_gpx_file(fp):
                trackseg: dict[str, np.ndarry | np.float64 | list] = {}

                for s in track["segments"]:
                    trackseg = extend(trackseg, s)
                    segment = extend(segment, s)

                gx.folium_map.add_start_top_markers(map, trackseg)  # sic

    gx.add_segment_to_map(
        the_map=map,
        segment=segment,
        fit_bounds=False,  # do this once at the end
        color_by="elevation",
        line_options={"weight": 8},
    )

    # Attach photos to the track
    for webp in webps:
        log.info(f"Attaching image {webp=} to track...")
        with PIL.Image.open(webp) as image:
            timestamp = timestamp_of(image)
            source = "gps"
            location = location_of(image)
            if not location:
                log.info(
                    f"Failed to extract location from {webp=}; interpolating from timestamp"
                )
                source = "timestamp"
                location = interpolate_location(timestamp, segment)

            if not location:
                log.warning(f"Could not obtain location for {webp=}; skipping")
                continue

            latitude, longitude = location
            log.debug(f"{webp=} {timestamp=} {latitude=} {longitude=}")

        # make the popup
        src = webp.name
        html, tag, text = Doc().tagtext()
        with tag("a", href=str(src)):
            html.stag("img", alt=str(src), src=str(src))

        popup: folium.Popup = folium.Popup(html=html.getvalue(), lazy=True)
        tooltip: folium.Tooltip = folium.Tooltip(text=html.getvalue())
        marker: folium.Marker = folium.Marker(
            location=(latitude, longitude),
            tooltip=tooltip,
            popup=popup,
            icon=folium.Icon(icon="camera", color="green"),
            lazy=True,
        )
        _ = marker.add_to(map)

    log.info("Adding overlays")
    # Enable map to go fullscreen
    _ = folium.plugins.Fullscreen().add_to(map)

    # "Spiderify" overlapping markers so they can be clicked
    oms = folium.plugins.OverlappingMarkerSpiderfier(
        keep_spiderfied=True,
        nearby_distance=100,  # px gap to decide markers overlap
        circle_spiral_switchover=10,  # how many markers to switch circle to spiral
        leg_weight=2.0,
    )
    _ = oms.add_to(map)

    # Fit map to viewport
    log.info("Fitting to viewport")
    boundary = map.get_bounds()
    map.fit_bounds(boundary, padding=(3, 3))

    # Render map, returning the rendered content
    log.info("Rendering map")
    html = BytesIONoClose()
    map.save(html)
    return html.getvalue()


@click.command(context_settings={"show_default": True, "ignore_unknown_options": True})
@click.argument(
    "configf", required=False, type=click.Path(dir_okay=False, path_type=Path)
)
@click.option("--debug", default=False, is_flag=True, help="Turn on verbose logging.")
@click.option(
    "--outf",
    required=False,
    default="map.html",
    type=click.Path(dir_okay=False, writable=True, allow_dash=True, path_type=None),
    help="Path to the produced map.",
)
@click.option(
    "--title", type=str, default="Untitled map", help="Title of the generated map."
)
@click.option(
    "--gpxs",
    type=click.Path(exists=True, dir_okay=True, path_type=Path),
    multiple=True,
    help="GPX files of the track.",
)
@click.option(
    "--photos",
    type=click.Path(exists=True, dir_okay=True, path_type=Path),
    multiple=True,
    help="Photos from the track.",
)
@click.option(
    "--overwrite", default=False, is_flag=True, help="Overwrite existing photos."
)
def pramblr(
    configf: Path,
    debug: bool,
    outf: str,
    title: str,
    gpxs: tuple[Path, ...],
    photos: tuple[Path, ...],
    overwrite: bool,
) -> None:
    """Process a set of GPX tracks into an interactive HTML/CSS/JS map, attaching photos."""

    # verbose logging
    if debug:
        log.setLevel(logging.DEBUG)

    # parse configuration if provided
    with open(configf, "r") as fp:
        config = yaml.loads(fp.read()) if configf else None
    prefix = configf.expanduser().parent if configf else "."
    log.debug(f"{configf=} {prefix=} {config=}")

    # output filename
    outf: Path = prefix / Path(config.get("outf", outf) if config else outf)
    log.debug(f"{outf=}")

    # title
    title: str = config.get("title", title) if config else title
    log.debug(f"{title=}")

    # build list of GPX tracks
    gpxs = (
        tuple(Path(p).expanduser() for p in config.get("gpxs", gpxs))
        if config
        else gpxs
    )
    log.debug(f"{gpxs=}")

    # build list of photos
    photos = (
        tuple(Path(p).expanduser() for p in config.get("photos", photos))
        if (config and config.get("photos", photos) is not None)
        else photos
    )
    log.debug(f"{photos=}")

    # ensure we have something to do!
    if len(gpxs) == 0:
        raise click.UsageError("no configuration or GPX files were provided")

    # convert photos if needed
    webps = convert_photos(outf, photos, overwrite)

    # make map and munge its HTML
    html = build_map(gpxs, webps)
    soup = bs4.BeautifulSoup(html, "html.parser")
    soup.title = soup.new_tag("title")
    soup.title.string = title

    # output map HTML
    with click.open_file(Path(outf).expanduser(), "w") as fp:
        _ = fp.write(soup.prettify())


if __name__ == "__main__":
    pillow_heif.register_heif_opener()
    pramblr()
